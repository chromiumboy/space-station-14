using Content.Client.Stylesheets;
using Content.Shared.Access;
using Content.Shared.Access.Components;
using Content.Shared.Access.Systems;
using Content.Shared.TurretControls;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using System.Linq;
using System.Numerics;

namespace Content.Client.TurretControls;

[GenerateTypedNameReferences]
public sealed partial class TurretControlsWindow : BaseWindow
{
    [Dependency] private IEntityManager _entManager = default!;
    [Dependency] private IPrototypeManager _protoManager = default!;
    private readonly IResourceCache _cache;

    public event Action? SendUpdateToServerAction;

    private EntityUid? _owner;
    private TurretControlsUiKey? _uiKey;

    private TurretControlsArmamentState _armamentState = TurretControlsArmamentState.Safe;
    private Dictionary<string, CheckBox> _accessButtons = new();
    private List<AccessGroupPrototype> _orderedAccessGroups = new();
    private Dictionary<AccessGroupPrototype, HashSet<AccessLevelPrototype>> _groupedAccessLevels = new();
    private int _tabIndex = 0;

    private event Action<int>? OnAccessGroupChangedEvent;
    public event Action<AccessLevelPrototype, bool>? OnAccessLevelChangedEvent;
    public event Action<TurretControlsArmamentState>? OnArmamentSettingChangedEvent;

    private Color _safeColor = Color.FromHex("#33e633");
    private Color _stunColor = Color.FromHex("#dfb827");
    private Color _lethalColor = Color.FromHex("#da2a2a");

    public TurretControlsWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _cache = IoCManager.Resolve<IResourceCache>();

        CloseButton.OnPressed += _ => Close();
        XamlChildren = ContentsContainer.Children;

        OnAccessGroupChangedEvent += OnAccessGroupChanged;

        var smallFont = _cache.NotoStack(size: 8);
        Footer.FontOverride = smallFont;
    }

    private void Initialize()
    {
        if (_owner == null || _uiKey == null)
            return;

        SafeButton.OnButtonUp += args => OnSafeButtonPressed();
        StunButton.OnButtonUp += args => OnStunButtonPressed();
        LethalButton.OnButtonUp += args => OnLethalButtonPressed();

        RefreshAccessControls();
    }

    private void OnUIChanged()
    {
        var ev = new TurretControlSettingsChangedMessage()
        {
            ArmamentState = _armamentState,
        };

        SendUpdateToServerAction?.Invoke();
    }

    private void OnSafeButtonPressed()
    {
        if (SafeButton.Pressed)
        {
            SafeButton.Pressed = false;
            return;
        }

        StunButton.Pressed = false;
        LethalButton.Pressed = false;
        ContentsContainer.Modulate = _safeColor;
        OnUIChanged();

        OnArmamentSettingChangedEvent?.Invoke(TurretControlsArmamentState.Safe);
    }

    private void OnStunButtonPressed()
    {
        if (StunButton.Pressed)
        {
            StunButton.Pressed = false;
            return;
        }

        SafeButton.Pressed = false;
        LethalButton.Pressed = false;
        ContentsContainer.Modulate = _stunColor;
        OnUIChanged();

        OnArmamentSettingChangedEvent?.Invoke(TurretControlsArmamentState.Stun);
    }

    private void OnLethalButtonPressed()
    {
        if (LethalButton.Pressed)
        {
            LethalButton.Pressed = false;
            return;
        }

        SafeButton.Pressed = false;
        StunButton.Pressed = false;
        ContentsContainer.Modulate = _lethalColor;
        OnUIChanged();

        OnArmamentSettingChangedEvent?.Invoke(TurretControlsArmamentState.Lethal);
    }

    public void SetOwnerAndUiKey(EntityUid owner, TurretControlsUiKey uiKey)
    {
        _owner = owner;
        _uiKey = uiKey;

        Initialize();
    }

    public void RefreshLinkedTurrets(List<(string, string)> turretStates)
    {
        var turretCount = turretStates.Count;
        var hasTurrets = turretCount > 0;

        NoLinkedTurretsText.Visible = !hasTurrets;
        LinkedTurretsContainer.Visible = hasTurrets;

        if (!hasTurrets)
            return;

        LinkedTurretsContainer.RemoveAllChildren();

        foreach (var turretState in turretStates)
        {
            var box = new BoxContainer()
            {
                HorizontalExpand = true,
            };

            var label = new Label()
            {
                Text = Loc.GetString("turret-controls-window-turret-status", ("device", turretState.Item1), ("status", turretState.Item2.ToUpper())),
                HorizontalAlignment = HAlignment.Left,
                Margin = new Thickness(10f, 0f, 10f, 0f),
                HorizontalExpand = true,
                SetHeight = 20f,
            };

            label.AddStyleClass("ConsoleText");

            box.AddChild(label);
            LinkedTurretsContainer.AddChild(box);
        }
    }

    public void RefreshAccessControls()
    {
        if (_owner == null)
            return;

        if (!_entManager.TryGetComponent<TurretControlsComponent>(_owner, out var turretControls))
            return;

        _groupedAccessLevels.Clear();
        _accessButtons.Clear();

        AccessGroupList.DisposeAllChildren();
        AccessLevelGrid.DisposeAllChildren();

        foreach (var accessGroup in turretControls.AccessGroups)
        {
            if (!_protoManager.TryIndex(accessGroup, out var accessGroupProto))
                continue;

            _groupedAccessLevels.Add(accessGroupProto, new());
        }

        if (_protoManager.TryIndex<AccessGroupPrototype>("General", out var generalAccessProto) &&
            _groupedAccessLevels.Keys.FirstOrDefault(x => x.ID != "General") == null)
        {
            _groupedAccessLevels.Add(generalAccessProto, new());
        }

        // Try to combine the access levels under broader access groups
        foreach (var accessLevel in turretControls.AccessLevels)
        {
            if (!_protoManager.TryIndex(accessLevel, out var accessLevelProto))
                continue;

            IEnumerable<AccessGroupPrototype> associatedGroups = _groupedAccessLevels.Keys.Where(x => x.Tags.Contains(accessLevelProto.ID) == true);

            if (!associatedGroups.Any() && generalAccessProto != null)
                _groupedAccessLevels[generalAccessProto].Add(accessLevelProto);

            else
            {
                foreach (var group in associatedGroups)
                    _groupedAccessLevels[group].Add(accessLevelProto);
            }
        }

        // Remove access groups with no entries
        foreach (var (group, accessLevels) in _groupedAccessLevels)
        {
            if (accessLevels.Count == 0)
                _groupedAccessLevels.Remove(group);
        }

        if (_tabIndex >= _groupedAccessLevels.Count)
            _tabIndex = _groupedAccessLevels.Count - 1;

        // Generate buttons for the access groups
        _orderedAccessGroups = _groupedAccessLevels.Keys.OrderBy(x => x.GetAccessGroupName()).ToList();

        for (int i = 0; i < _orderedAccessGroups.Count; i++)
        {
            var accessGroup = _orderedAccessGroups[i];

            var newButton = new MonoToneButton
            {
                Text = accessGroup.Name != null ? Loc.GetString(accessGroup.Name) : "???",
                ToggleMode = true,
                Pressed = _tabIndex == _orderedAccessGroups.IndexOf(accessGroup),
            };

            AccessGroupList.AddChild(newButton);

            newButton.OnPressed += _ =>
            {
                OnAccessGroupChangedEvent?.Invoke(newButton.GetPositionInParent());
            };

            // Style the button depending where it is on the list
            if (_orderedAccessGroups.Count > 1)
            {
                if (i == 0)
                    newButton.AddStyleClass("OpenLeft");

                else if (_orderedAccessGroups.Count > 1 && i == (_orderedAccessGroups.Count - 1))
                    newButton.AddStyleClass("OpenRight");

                else
                    newButton.AddStyleClass("OpenBoth");
            }
        }

        // Generate buttons for the current tab
        var accessLevelsForTab = _groupedAccessLevels[_orderedAccessGroups[_tabIndex]];
        accessLevelsForTab = accessLevelsForTab.OrderBy(x => x.GetAccessLevelName()).ToHashSet();

        foreach (var accessLevel in accessLevelsForTab)
        {
            var newButton = new MonoToneCheckBox
            {
                Text = accessLevel.GetAccessLevelName(),
                ToggleMode = true,
                Margin = new Thickness(0f, 2f),
                //Pressed = accessReader.AccessLists.Any(x => x.Any(y => y == accessLevel)),
            };

            AccessLevelGrid.AddChild(newButton);
            _accessButtons.Add(accessLevel.ID, newButton);

            newButton.OnPressed += args =>
            {
                OnAccessLevelChangedEvent?.Invoke(accessLevel, newButton.Pressed);
            };
        }
    }

    protected override DragMode GetDragModeFor(Vector2 relativeMousePos)
    {
        return DragMode.Move;
    }

    private void OnAccessGroupChanged(int newTabIndex)
    {
        var oldAccessGroupButton = AccessGroupList.GetChild(_tabIndex) as Button;

        if (oldAccessGroupButton == null)
            return;

        oldAccessGroupButton.Pressed = (newTabIndex == _tabIndex);

        if (newTabIndex == _tabIndex)
            return;

        _tabIndex = newTabIndex;
        RefreshAccessControls();
    }
}

public sealed class MonoToneButton : Button
{
    public float BorderThickness = 2f;
    public Color ForegroundColor = Color.White;
    public Color BackgroundColor = new Color(55, 55, 55);

    private PanelContainer _innerPanel;

    public MonoToneButton()
    {
        Label.AddStyleClass("ConsoleText");

        ModulateSelfOverride = ForegroundColor;

        _innerPanel = new PanelContainer()
        {
            HorizontalExpand = true,
            VerticalExpand = true,
        };

        AddChild(_innerPanel);
        _innerPanel.SetPositionFirst();
    }

    protected override void StylePropertiesChanged()
    {
        base.StylePropertiesChanged();

        if (!this.TryGetStyleProperty<StyleBoxTexture>(StylePropertyStyleBox, out var box))
            return;

        Label.ModulateSelfOverride = this.Pressed ? BackgroundColor : ForegroundColor;

        _innerPanel.PanelOverride = new StyleBoxTexture(box)
        {
            Modulate = this.Pressed ? ForegroundColor : BackgroundColor,
        };

        _innerPanel.Margin = new Thickness
            (BorderThickness - box.GetContentMargin(StyleBox.Margin.Left),
            BorderThickness - box.GetContentMargin(StyleBox.Margin.Top),
            BorderThickness - box.GetContentMargin(StyleBox.Margin.Right),
            BorderThickness - box.GetContentMargin(StyleBox.Margin.Bottom));
    }
}

public sealed class MonoToneCheckBox : CheckBox
{
    public MonoToneCheckBox()
    {
        Label.AddStyleClass("ConsoleText");

        TextureRect.RemoveStyleClass(StyleClassCheckBox);
        TextureRect.AddStyleClass(StyleNano.StyleClassCheckBoxWhite);
    }

    protected override void DrawModeChanged()
    {
        base.DrawModeChanged();

        if (TextureRect != null)
        {
            if (Pressed)
                TextureRect.AddStyleClass(StyleNano.StyleClassCheckBoxWhiteChecked);
            else
                TextureRect.RemoveStyleClass(StyleNano.StyleClassCheckBoxWhiteChecked);
        }
    }
}

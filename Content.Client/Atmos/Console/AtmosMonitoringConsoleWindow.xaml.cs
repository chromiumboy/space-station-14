using Content.Client.Pinpointer.UI;
using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Content.Shared.Atmos.Components;
using Content.Shared.Atmos.Monitor;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Map;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace Content.Client.Atmos.Console;

[GenerateTypedNameReferences]
public sealed partial class AtmosMonitoringConsoleWindow : FancyWindow
{
    private readonly IEntityManager _entManager;
    private readonly SpriteSystem _spriteSystem;
    private readonly IGameTiming _gameTiming;

    private IResourceCache _cache;

    private const float BlinkFrequency = 1f;

    private EntityUid? _owner;
    private NetEntity? _trackedEntity;

    public event Action<NetEntity?>? SendAtmosMonitoringConsoleMessageAction;

    private VectorFont _noAlertFont;

    private bool _autoScrollActive = false;
    private bool _autoScrollAwaitsUpdate = false;

    private int _currentAlertCount = 0;

    private Dictionary<AtmosMonitoringConsoleGroup, (SpriteSpecifier.Texture, Color)> _groupBlips = new()
    {
        { AtmosMonitoringConsoleGroup.GasVentPump, (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/NavMap/beveled_square.png")), Color.DarkGray) },
        { AtmosMonitoringConsoleGroup.GasVentScrubber, (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/NavMap/beveled_circle.png")), Color.DarkGray) },
        { AtmosMonitoringConsoleGroup.AirAlarm, (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/NavMap/beveled_star.png")), Color.White) },
    };

    public AtmosMonitoringConsoleWindow(AtmosMonitoringConsoleBoundUserInterface userInterface, EntityUid? owner)
    {
        RobustXamlLoader.Load(this);
        _entManager = IoCManager.Resolve<IEntityManager>();
        _gameTiming = IoCManager.Resolve<IGameTiming>();
        _cache = IoCManager.Resolve<IResourceCache>();

        _spriteSystem = _entManager.System<SpriteSystem>();
        _owner = owner;

        // Pass owner to nav map
        NavMap.Owner = _owner;

        // Set nav map grid uid
        var stationName = Loc.GetString("atmos-monitoring-window-unknown-location");

        if (_entManager.TryGetComponent<TransformComponent>(owner, out var xform))
        {
            NavMap.MapUid = xform.GridUid;

            // Assign station name      
            if (_entManager.TryGetComponent<MetaDataComponent>(xform.GridUid, out var stationMetaData))
                stationName = stationMetaData.EntityName;

            var msg = new FormattedMessage();
            msg.AddMarkup(Loc.GetString("atmos-monitoring-window-station-name", ("stationName", stationName)));

            StationName.SetMessage(msg);
        }

        else
        {
            StationName.SetMessage(stationName);
            NavMap.Visible = false;
        }

        // Set trackable entity selected action
        NavMap.TrackedEntitySelectedAction += SetTrackedEntityFromNavMap;

        // Update nav map
        NavMap.ForceNavMapUpdate();

        MasterTabContainer.SetTabTitle(0, Loc.GetString("atmos-monitoring-window-tab-no-alerts"));
        MasterTabContainer.SetTabTitle(1, Loc.GetString("atmos-monitoring-window-tab-air-alarms"));

        // Set UI toggles
        ShowPipeNetwork.OnToggled += _ => OnShowPipeNetworkToggled();
        ShowInactiveAirAlarms.OnToggled += _ => OnInactiveAirAlarmsToggled();

        // Set power monitoring message action
        SendAtmosMonitoringConsoleMessageAction += userInterface.SendAtmosMonitoringConsoleMessage;

        _noAlertFont = new VectorFont(_cache.GetResource<FontResource>("/Fonts/NotoSans/NotoSans-Regular.ttf"), 18);
    }


    private void OnShowPipeNetworkToggled()
    {
        NavMap.ShowPipeNetwork = ShowPipeNetwork.Pressed;
    }

    private void OnInactiveAirAlarmsToggled()
    {

    }

    private void OnSilenceAlertsToggled(NetEntity netEntity, bool toggleState)
    {
        if (!_entManager.TryGetComponent<AtmosMonitoringConsoleComponent>(_owner, out var console))
            return;

        if (toggleState)
            console.SilencedAlerts.Add(netEntity);
        else
            console.SilencedAlerts.Remove(netEntity);
    }

    public void ShowEntites(EntityCoordinates? monitorCoords, AtmosMonitoringConsoleEntry[] activeAlarms, AtmosFocusDeviceData? focusData)
    {
        if (_owner == null)
            return;

        if (!_entManager.TryGetComponent<AtmosMonitoringConsoleComponent>(_owner.Value, out var console))
            return;

        if (_trackedEntity != focusData?.NetEntity)
        {
            SendAtmosMonitoringConsoleMessageAction?.Invoke(_trackedEntity);
            focusData = null;
        }

        // Reset nav map values
        NavMap.TrackedCoordinates.Clear();
        NavMap.TrackedEntities.Clear();

        //
        foreach (var datum in console.AtmosDevices)
        {
            if (!NavMap.Visible)
                continue;

            // Skip inactive air alarms if toggle is off
            if (datum.Group == AtmosMonitoringConsoleGroup.AirAlarm &&
                !ShowInactiveAirAlarms.Pressed)
            {
                var airAlarm = activeAlarms.FirstOrNull(a => a.Entity == datum.NetEntity);

                if (airAlarm == null || airAlarm.Value.AlarmState <= AtmosAlarmType.Normal)
                    continue;
            }

            // Skip atmos devices if the pipe network is toggled off
            if (datum.Group != AtmosMonitoringConsoleGroup.AirAlarm &&
                !ShowPipeNetwork.Pressed)
                continue;

            AddTrackedEntityToNavMap(datum, activeAlarms);
        }

        // Show monitor location
        var mon = _entManager.GetNetEntity(_owner);

        if (monitorCoords != null && mon != null)
        {
            var texture = _spriteSystem.Frame0(new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/NavMap/beveled_circle.png")));
            var blip = new NavMapBlip(monitorCoords.Value, texture, Color.Cyan, true, false);
            NavMap.TrackedEntities[mon.Value] = blip;
        }

        AlertsTable.RemoveAllChildren();
        AirAlarmsTable.RemoveAllChildren();

        _currentAlertCount = 0;

        foreach (var entry in activeAlarms)
        {
            MakeNewAlarmEntry(entry, console, focusData);
        }

        if (MasterTabContainer.CurrentTab == 0 && _currentAlertCount == 0)
        {
            var label = new Label()
            {
                Text = Loc.GetString("atmos-monitoring-window-no-active-alerts"),
                HorizontalExpand = true,
                VerticalExpand = true,
                HorizontalAlignment = HAlignment.Center,
                VerticalAlignment = VAlignment.Bottom,
                FontColorOverride = Color.White,
                FontOverride = _noAlertFont,
            };

            AlertsTable.AddChild(label);

            var newlabel = new Label()
            {
                Text = Loc.GetString("atmos-monitoring-window-situation-green"),
                HorizontalExpand = true,
                VerticalExpand = true,
                HorizontalAlignment = HAlignment.Center,
                VerticalAlignment = VAlignment.Top,
                FontColorOverride = StyleNano.GoodGreenFore,
                FontOverride = _noAlertFont,
            };

            AlertsTable.AddChild(newlabel);
        }

        if (_currentAlertCount == 0)
            MasterTabContainer.SetTabTitle(0, Loc.GetString("atmos-monitoring-window-tab-no-alerts"));

        else
            MasterTabContainer.SetTabTitle(0, Loc.GetString("atmos-monitoring-window-tab-alerts", ("value", _currentAlertCount)));

        // Update nav map
        NavMap.ForceNavMapUpdate();

        // Auto-scroll reenable
        if (_autoScrollAwaitsUpdate)
        {
            _autoScrollActive = true;
            _autoScrollAwaitsUpdate = false;
        }
    }

    private void AddTrackedEntityToNavMap(AtmosDeviceNavMapData metaData, AtmosMonitoringConsoleEntry[] activeAlarms)
    {
        if (!_groupBlips.TryGetValue(metaData.Group, out var data))
            return;

        var coords = _entManager.GetCoordinates(metaData.NetCoordinates);
        var texture = data.Item1;
        var color = (metaData.Color != null) ? metaData.Color * data.Item2 : data.Item2;

        if (metaData.Group == AtmosMonitoringConsoleGroup.AirAlarm)
        {
            foreach (var alarm in activeAlarms)
            {
                if (alarm.Entity == metaData.NetEntity)
                {
                    if (alarm.AlarmState >= AtmosAlarmType.Warning)
                        color = new Color(255, 205, 0);
                    else
                        color = Color.LimeGreen;

                    //color = ChangeColorBrightness(DetermineAlertColoration(alarm.AlarmState), 1.5f);
                    break;
                }
            }
        }

        var selectable = (metaData.Group == AtmosMonitoringConsoleGroup.AirAlarm);

        var blip = new NavMapBlip(coords, _spriteSystem.Frame0(texture), color.Value, _trackedEntity == metaData.NetEntity, selectable);
        NavMap.TrackedEntities[metaData.NetEntity] = blip;
    }

    private void MakeNewAlarmEntry(AtmosMonitoringConsoleEntry entry, AtmosMonitoringConsoleComponent console, AtmosFocusDeviceData? focusData = null)
    {
        bool noActiveAlert = (entry.AlarmState <= AtmosAlarmType.Normal || console.SilencedAlerts.Contains(entry.Entity));

        if (noActiveAlert && MasterTabContainer.CurrentTab == 0)
            return;

        if (!noActiveAlert)
            _currentAlertCount += 1;

        var mainContainer = new AtmosAlarmEntryContainer(entry.Entity, _entManager.GetCoordinates(entry.Coordinates), entry, focusData);

        mainContainer.FocusButton.OnButtonUp += args =>
        {
            var prevTrackedEntity = _trackedEntity;

            if (_trackedEntity == entry.Entity)
            {
                _trackedEntity = null;
            }

            else
            {
                _trackedEntity = entry.Entity;
                NavMap.CenterToCoordinates(_entManager.GetCoordinates(entry.Coordinates));
            }

            // Send message to console that the focus has changed
            SendAtmosMonitoringConsoleMessageAction?.Invoke(_trackedEntity);

            UpdateAlertsTable(_trackedEntity, prevTrackedEntity);
        };

        // Silence alert for this console
        mainContainer.SilenceCheckBox.Pressed = console.SilencedAlerts.Contains(entry.Entity);
        mainContainer.SilenceCheckBox.OnToggled += _ => OnSilenceAlertsToggled(entry.Entity, mainContainer.SilenceCheckBox.Pressed);

        // Add child
        if (MasterTabContainer.CurrentTab == 0)
            AlertsTable.AddChild(mainContainer);

        else
            AirAlarmsTable.AddChild(mainContainer);
    }

    private void UpdateAlertsTable(NetEntity? currTrackedEntity, NetEntity? prevTrackedEntity)
    {
        foreach (var alert in AlertsTable.Children)
        {
            if (alert is not AtmosAlarmEntryContainer)
                continue;

            var castAlert = (AtmosAlarmEntryContainer) alert;

            if (castAlert.AirAlarmUid == prevTrackedEntity)
                castAlert.RemoveStyleClass(StyleNano.StyleClassButtonColorGreen);

            else if (castAlert.AirAlarmUid == currTrackedEntity)
                castAlert.AddStyleClass(StyleNano.StyleClassButtonColorGreen);

            if (castAlert?.Coordinates == null)
                continue;

            if (NavMap.TrackedEntities.TryGetValue(castAlert.AirAlarmUid, out var data))
            {
                data = new NavMapBlip
                    (data.Coordinates,
                    data.Texture,
                    (currTrackedEntity == null || castAlert.AirAlarmUid == currTrackedEntity) ? Color.LimeGreen : Color.LimeGreen * Color.DimGray,
                    castAlert.AirAlarmUid == currTrackedEntity);

                NavMap.TrackedEntities[castAlert.AirAlarmUid] = data;
            }
        }
    }

    private void SetTrackedEntityFromNavMap(NetEntity? netEntity)
    {
        if (netEntity == null)
            return;

        _trackedEntity = netEntity;

        // Get the scroll position of the selected entity on the selected button the UI
        ActivateAutoScrollToFocus();

        // Send message to console that the focus has changed
        SendAtmosMonitoringConsoleMessageAction?.Invoke(_trackedEntity);
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        AutoScrollToFocus();

        // Warning sign pulse        
        //var lit = _gameTiming.RealTime.TotalSeconds % BlinkFrequency > BlinkFrequency / 2f;
        //SystemWarningPanel.Modulate = lit ? Color.White : new Color(178, 178, 178);
    }

    private void ActivateAutoScrollToFocus()
    {
        _autoScrollActive = false;
        _autoScrollAwaitsUpdate = true;
    }

    private void AutoScrollToFocus()
    {
        if (!_autoScrollActive)
            return;

        var scroll = MasterTabContainer.Children.ElementAt(MasterTabContainer.CurrentTab) as ScrollContainer;
        if (scroll == null)
            return;

        if (!TryGetVerticalScrollbar(scroll, out var vScrollbar))
            return;

        if (!TryGetNextScrollPosition(out float? nextScrollPosition))
            return;

        vScrollbar.ValueTarget = nextScrollPosition.Value;

        if (MathHelper.CloseToPercent(vScrollbar.Value, vScrollbar.ValueTarget))
            _autoScrollActive = false;
    }

    private bool TryGetVerticalScrollbar(ScrollContainer scroll, [NotNullWhen(true)] out VScrollBar? vScrollBar)
    {
        vScrollBar = null;

        foreach (var child in scroll.Children)
        {
            if (child is not VScrollBar)
                continue;

            var castChild = child as VScrollBar;

            if (castChild != null)
            {
                vScrollBar = castChild;
                return true;
            }
        }

        return false;
    }

    private bool TryGetNextScrollPosition([NotNullWhen(true)] out float? nextScrollPosition)
    {
        nextScrollPosition = null;

        var scroll = MasterTabContainer.Children.ElementAt(MasterTabContainer.CurrentTab) as ScrollContainer;
        if (scroll == null)
            return false;

        var container = scroll.Children.ElementAt(0) as BoxContainer;
        if (container == null || container.Children.Count() == 0)
            return false;

        // Exit if the heights of the children haven't been initialized yet
        if (!container.Children.Any(x => x.Height > 0))
            return false;

        nextScrollPosition = 0;

        foreach (var control in container.Children)
        {
            if (control == null || control is not AtmosAlarmEntryContainer)
                continue;

            if (((AtmosAlarmEntryContainer) control).AirAlarmUid == _trackedEntity)
                return true;

            nextScrollPosition += control.Height;
        }

        // Failed to find control
        nextScrollPosition = null;

        return false;
    }
}
